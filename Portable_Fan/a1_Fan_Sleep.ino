// Copyright (c) 2025 Otto
// Лицензия: MIT (см. LICENSE)


// --- Настройки для ATmega8L-8AU BOD-отключения ---
#define BODS 5   // бит 5 MCUCSR
#define BODSE 2  // бит 2 MCUCSR

volatile uint8_t state = 0;  // 0 = сон, 1-4 = режимы мощности мотора

// Настройка ШИМ для регулировки мотора
void setup_PWM_fast() {
  TCCR1A = (1 << COM1A1) | (1 << WGM11);               // Режим Fast PWM, неинвертирующий
  TCCR1B = (1 << WGM13) | (1 << WGM12) | (1 << CS11);  // Делитель = 8

  ICR1 = 28;           // Задаёт период ШИМ (TOP = 28 → частота ~34.48 кГц)
  DDRB |= (1 << PB1);  // Настраивает PB1 как ВЫХОД (OC1A)
}

// Устанавливает скважность ШИМ
void set_PWM_duty(uint16_t v) {
  OCR1A = v;  // Записывает значение в регистр сравнения (0–28)
}

// Режим глубокого сна
void enter_sleep() {
  clearDisplay();  // Очищаем дисплей

  // Отключение периферии через регистры
  ADCSRA &= ~(1 << ADEN);  // Отключить АЦП
  SPCR &= ~(1 << SPE);     // Отключить SPI
  TWCR &= ~(1 << TWEN);    // Отключить TWI (I2C)

  // Сбрасываем «висящий» флаг INT0
  GIFR |= (1 << INTF0);

  // Выключаем BOD на время сна
  cli();
  MCUCSR |= (1 << BODSE) | (1 << BODS);
  MCUCSR &= ~(1 << BODSE);
  sei();


  // Настройка глубокого режима сна (Power-down)
  MCUCR &= ~((1 << SM2) | (1 << SM1) | (1 << SM0));  // SM2=0, SM1=1, SM0=0
  MCUCR |= (1 << SM1) | (1 << SE);                   // Включаем SE

  // Засыпаем (пробуждение — по низкому уровню на INT0)
  asm volatile("sleep");

  // Сразу после пробуждения выключаем SE, чтобы не залететь обратно в сон
  MCUCR &= ~(1 << SE);
}

// Обработчик прерывания от кнопки с антидребезгом
ISR(INT0_vect) {
  delay(15);  // Антидребезг

  // Проверяем, что кнопка всё ещё нажата
  if (!(PIND & (1 << PIND2))) {  // Если кнопка всё ещё нажата
    state = (state + 1) % 5;     // Циклический счетчик (0 → 1 → 2 → 3 → 4 → 0)

    // Ожидаем отпускания кнопки перед следующим срабатыванием
    while (!(PIND & (1 << PIND2))) {
      clearDisplay();  // Очищаем дисплей во время удержания кнопки
      delay(10);       // Ждём, пока кнопка не будет отпущена
    }
  }
}

// Обработчик первоначальной настройки ШИМ-сигнала и режима сна
void setupFanSleep() {
  pinMode(2, INPUT_PULLUP);  // Кнопка на PD2 (Arduino Pin 2) с внутренней подтяжкой

  MCUCR &= ~((1 << ISC01) | (1 << ISC00));  // Настраиваем INT0 на «низкий уровень» (ISC01=0, ISC00=0)
  GICR |= (1 << INT0);                      // Разрешаем внешнее прерывание INT0

  sei();             // Разрешаем глобальные прерывания
  setup_PWM_fast();  // Инициализация ШИМ
}