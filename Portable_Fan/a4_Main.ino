// Copyright (c) 2025 Otto
// Лицензия: MIT (см. LICENSE)


const uint32_t DISPLAY_INTERVAL = 3000000UL;  // Интервал показа одного значения — 3 секунды (в микросекундах)

uint32_t lastToggle = 0;  // Время последнего переключения режима отображения (в микросекундах)
uint8_t displayMode = 0;  // 0 = режим, 1 = заряд (Battery), 2 = температура (Temp)
uint8_t prevState = 0;    // Предыдущее состояние режима работы "state"

// Настройка пинов на старте
void setup() {
  setupFanSleep();       // Настройка ШИМ-сигнала и режима сна (прерывание по кнопке)
  resetPortTemp();       // Отключение питания делителя напряжения NTC термистора
  setup_MultiDisplay();  // Инициализация мультиплексного семисегментного индикатора с 5-ю выводами

  lastToggle = micros();    // Записывает текущее время для отслеживания интервалов переключения режимов отображения
  prevState = state;        // Сохраняем текущее состояние устройства "state" как предыдущее, чтобы отслеживать изменения
  displayMode = 0;          // Устанавливает начальный режим отображения
  setDisplayNumber(state);  // Отображает номер текущего режима
}

// Главный цикл
void loop() {
  // Если НЕ в режиме сна
  if (state != 0) {
    // При смене режима сбрасываем цикл показа
    if (state != prevState) {
      prevState = state;        // Сохраняем новый режим как предыдущий
      displayMode = 0;          // Устанавливаем режим отображения
      lastToggle = micros();    // Сбрасываем таймер
      clearDisplay();           // Очищаем дисплей
      setDisplayNumber(state);  // Отображаем номер текущего режима
    }

    // Переход к следующему элементу показа раз в "DISPLAY_INTERVAL" (3 секунды)
    if ((uint32_t)(micros() - lastToggle) >= DISPLAY_INTERVAL) {
      lastToggle = micros();                // Сбрасываем таймер
      displayMode = (displayMode + 1) % 3;  // Переходим к следующему режиму отображения (циклически)
      clearDisplay();                       // Очищаем дисплей

      if (displayMode == 0) {
        setDisplayNumber(state, false);  // Показываем номер текущего режима
      } else if (displayMode == 1) {
        setDisplayNumber(Battery(), false);  // Показываем уровень заряда аккумулятора
      } else {
        // При показе температуры включаем «температурный» сегмент, что бы было легко оличить температуру от напряжения
        setDisplayNumber(Temp(), true);  // Показываем температуру
      }
    }

    // Входим в режим сна
  } else {
    clearDisplay();                              // Очищаем дисплей
    resetPortTemp();                             // Отключить делитель перед сном
    TCCR1A &= ~((1 << COM1A1) | (1 << COM1A0));  // Выключаем генерацию ШИМ-сигнала
    PORTB &= ~(1 << PB1);                        // PB1 = LOW
    enter_sleep();                               // Входим в сон
  }

  // Управление PWM по режиму
  switch (state) {
    case 0:
      // Сон — уже обработан выше
      break;

    case 1:
      TCCR1A |= (1 << COM1A1);   // Включаем ШИМ
      TCCR1A &= ~(1 << COM1A0);  // Настройка режима ШИМ
      set_PWM_duty(9);           // 32% мощности мотора
      break;

    case 2:
      set_PWM_duty(14);  // 50% мощности мотора
      break;

    case 3:
      set_PWM_duty(21);  // 75% мощности мотора
      break;

    case 4:                                        // 100% мощности мотора (постоянное напряжение на порту PB1)
      TCCR1A &= ~((1 << COM1A1) | (1 << COM1A0));  // Выключаем генерацию ШИМ-сигнала
      PORTB |= (1 << PB1);                         // PB1 = HIGH
      break;
  }
}